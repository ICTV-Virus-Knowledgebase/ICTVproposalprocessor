---
title: "ICTV validate proposals"
params:
  # inputs
  prev_taxa_fname: ./current_msl/taxonomy_node_names.all.txt
  rank_fname: ./current_msl/taxonomy_level.txt
  cv_xlsx: ./TP_Template_Excel_module_2022_v2.xlsx
  cv_sheet: "Menu Items (Do not change)"
  proposals_dir: ./proposals
  out_dir: ./results
  # set to false when editing .xlsx files to fix
  unzipTop:    FALSE
  unzipPro:    FALSE
  # output files
  tmp_dir: ./tmp
  dest_msl: 38
  merged:  load_next_msl.txt
  status:  merged_status.txt
  
output: html_document
---

QC MSL38: https://uab-lefkowitz.atlassian.net/browse/IVK-123
Merge++:  https://uab-lefkowitz.atlassian.net/browse/IVK-22

This script 
  * load previous MSL data
  * scans params$zip_dir for *.zip (proposal zips)
  * iterates over each proposal zip
    * unzips it into params$tmp_dir
    * reads the proposal.xlsx file into a data frame
    * merge each row (change)
      * match up to existing taxon
      * QC data, etc.
      * implement change in new MSL data frame
      * record errors, warnings, etc
      * create merged change set in one merged dataframe
  * write merged proposal data frame to a Unicode(UTF-16LE) TSV file (params$merged) that can be loaded into MSSQL on Windows using "Import Data...." 
  * write a status sheet listing parsing and QC success/fail status for each proposal (params$status)
  * write new MSL load & updates to prev_msl.out_*
  
```{r setup, include=FALSE}
library(yaml)
library(tidyverse)
library(readxl)
library(writexl) # another option library(openxlsx)
#library(gtools) # for mixedsort/mixedorder

library(knitr) #kable
# debug - echo everything
knitr::opts_chunk$set(echo = TRUE)

```

# load previous MSLs
```{r load prev MSL, echo=F}

taxonomy_node_names = c("taxnode_id","parent_id","tree_id","msl_release_num","level_id","name","ictv_id","molecule_id","abbrev_csv","genbank_accession_csv","genbank_refseq_accession_csv","refseq_accession_csv","isolate_csv","notes","is_ref","is_official","is_hidden","is_deleted","is_deleted_next_year","is_typo","is_renamed_next_year","is_obsolete","in_change","in_target","in_filename","in_notes","out_change","out_target","out_filename","out_notes","start_num_sort","row_num","filename","xref","realm_id","realm_kid_ct","realm_desc_ct","subrealm_id","subrealm_kid_ct","subrealm_desc_ct","kingdom_id","kingdom_kid_ct","kingdom_desc_ct","subkingdom_id","subkingdom_kid_ct","subkingdom_desc_ct","phylum_id","phylum_kid_ct","phylum_desc_ct","subphylum_id","subphylum_kid_ct","subphylum_desc_ct","class_id","class_kid_ct","class_desc_ct","subclass_id","subclass_kid_ct","subclass_desc_ct","order_id","order_kid_ct","order_desc_ct","suborder_id","suborder_kid_ct","suborder_desc_ct","family_id","family_kid_ct","family_desc_ct","subfamily_id","subfamily_kid_ct","subfamily_desc_ct","genus_id","genus_kid_ct","genus_desc_ct","subgenus_id","subgenus_kid_ct","subgenus_desc_ct","species_id","species_kid_ct","species_desc_ct","taxa_kid_cts","taxa_desc_cts","inher_molecule_id","left_idx","right_idx","node_depth","lineage","cleaned_name","cleaned_problem","flags","_numKids","_out_target_parent","_out_target_name","rank","tree","realm","subrealm","kingdom","subkingdom","phylum","subphylum","class","subclass","order","suborder","family","subfamily","genus","subgenus","species","molecule","inher_molecule")
prevMSLs=read.delim(file=params$prev_taxa_fname,header=FALSE,stringsAsFactors=TRUE,col.names=taxonomy_node_names)
cat("Previous taxa:",dim(prevMSLs), " from ",params$prev_taxa_fname,"\n")

# CV loads
rankCV = read.delim(file=params$rank_fname,header=TRUE, stringsAsFactors=TRUE,na.strings=c("NULL"))
rownames(rankCV) = rankCV$id
cat("RankCV: ", dim(rankCV), " from ",params$rank_fname,"\n")
```
# Load CVs for Proposal QC
```{r load cvs}
proposalCV = data.frame(read_excel(params$cv_xlsx,sheet = params$cv_sheet,col_names = FALSE))
#cvDf = data.frame(trib[,])  # remove "select one" line

cvList=list()
for(cv_col in 1:ncol(proposalCV)) {
  cv_name = proposalCV[1,cv_col]
  cv = proposalCV[,cv_col][-1]
  cvList[[cv_name]]=c(cv[!is.na(cv)],NA)
}

# map to output names
cvNameMap = c(
  "Genome coverage"=    "isComplete",
  "Genome composition"= "molecule",
  "Host/Source"=        "hostSource",
  "Change"=             "change",
  "Rank"=               "rank"  
)

names(cvList)=cvNameMap[names(cvList)]
```

# scan for proposal .xlsx files
```{r scan for proposal matching xlsx and docx}
# 
# error reporting data frame
# 
allErrorDf = data.frame(
  "folder" = character(),
  "id" = character(),
  "docx" = character(),
  "xlsx" = character(),
  "level" = factor(levels=c("ERROR","WARNING","INFO")),
  "message" = character(),
  "notes" = character()
)
dir.create(params$out_dir,recursive=T)

#
# scan DOCX
#
proposals = data.frame(docx=list.files(path="proposals",pattern="20[0-9][0-9].[0-9A-Z]+.*.v*.*.docx", recursive=T, full.names=TRUE) )
proposals$id       = gsub(".*/(20[0-9]+.[0-9A-Z]+).[^/]+.docx$","\\1",proposals$docx)
proposals$basename = gsub(".*/(20[0-9]+.[0-9A-Z]+.[^/]+).docx$","\\1",proposals$docx)
proposals$folder   = gsub(".*/([^/]+)/(20[0-9]+.[0-9A-Z]+).[^/]+.docx$","\\1",proposals$docx)

# check for duplicate Proposal IDs
dups = duplicated(proposals$id)
if(sum(dups) > 0) {
  errorDf = proposals[proposals$id %in% proposals$id[dups], c("folder", "id", "docx","xlsx")]
  errorDf$level = "ERROR"
  errorDf$message = "duplicate proposal ID"
  allErrorDf = rbind(allErrorDf, errorDf)
  # output
  kable(errorDf,caption = paste0("QC01: ERRORS: dupliate docx proposal IDs"))
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC01.docx_duplicate_ids.xlsx"))
  allErrorDf=rbind(allErrorDf,errorDf)
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))

}
rownames(proposals)=proposals$id

#
# scan XLSX
#
xlsxs = data.frame(xlsx=list.files(path="proposals",pattern="20[0-9][0-9].[^.]+.*.v*.*.xlsx", recursive=T, full.names=TRUE) )
xlsxs$basename = gsub(".*/(20[0-9]+.[0-9A-Z]+.[^/]+).xlsx$","\\1",xlsxs$xlsx)
xlsxs$xlsxID   = gsub(".*/(20[0-9]+.[0-9A-Z]+).[^/]+.xlsx$","\\1",xlsxs$xlsx)

dups = duplicated(xlsxs$basename)
if( sum(dups) > 0 ) {
  kable(caption=paste0("ERROR: XLSX dupliate proposal IDs"),
        x=proposals[proposals$id %in% proposals$id[dups],])
}
rownames(xlsxs) = xlsxs$basename

#
# merge XLSX list into DOCX list, verify
#
proposals$xlsx = xlsxs[proposals$basename,"xlsx"]
missing= is.na(proposals$xlsx)
if( sum(missing) > 0 ) {
  errorDf= proposals[missing,c("folder","id","docx")]
  # suggest possible matches based on ID
  errorDf$xlsx= NA 
  errorDf$level= "ERROR"
  errorDf$message = "DOCX has no matching XLSX"
  errorDf$notes= "Suggestions: none"
  for(row in rownames(errorDf) ) {
    guesses = sum(xlsxs$xlsxID==errorDf[row,"id"])
    if( guesses == 1 ) { 
      # if we have a unique guess, then make it a WARNING, and use that guess
      proposals[row,"xlsx"]=xlsxs[xlsxs$xlsxID==errorDf[row,"id"],"xlsx"]
      errorDf[row,]$xlsx = proposals[row,"xlsx"]
      errorDf[row,]$level = "WARNING"
      errorDf[row,]$notes = paste("Using best guess:",proposals[row,"xlsx"])
    } else if( guesses > 1 ) {
      # just list all the options we found
      errorDf[row,"notes"] = paste("SUGGESTIONS:",paste(paste0(xlsxs[xlsxs$xlsxID==errorDf[row,"docxID"],"basename"],".xslx"),collapse=", "))
    }
  }
  # QC output
  kable(errorDf,caption = paste0("QC02: ERRORS: DOCX without matching XLSX"))
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC02.docx_without_matching_xlsx.xlsx"))
  allErrorDf=rbind(allErrorDf,errorDf)
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))

  }
```

# Load summary

```{r load_summary,echo=FALSE}
kable(caption=paste0("SUMMARY: Proposal .xlsx file found in ",params$proposals_dir,"/"),
      x=data.frame(nProposals=summary(as.factor(proposals$folder))),)
```

## QC setup
```{r qc_setup, echo=FALSE}

# dput(unname(as.vector(df[1,])))
xlsx_v1_row2=c(
    "CURRENT TAXONOMY", NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, "PROPOSED TAXONOMY", NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, "SPECIFY PROPOSED CHANGE", NA_character_, 
    "COMMENTS", NA, NA, NA, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_
    )

xlsx_v2_row2=c(
    "CURRENT TAXONOMY", NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    "PROPOSED TAXONOMY", NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, "SPECIFY PROPOSED CHANGE", NA_character_, 
    "COMMENTS"
    )

# dput(unname(as.vector(df[2,])))
xlsx_v1_row3=c("Realm", "Subrealm", "Kingdom", "Subkingdom", 
    "Phylum", "Subphylum", "Class", "Subclass", "Order", "Suborder", 
    "Family", "Subfamily", "Genus", "Subgenus", "Species", "Exemplar GenBank Accession Number", 
    "Realm", "Subrealm", "Kingdom", "Subkingdom", "Phylum", "Subphylum", 
    "Class", "Subclass", "Order", "Suborder", "Family", "Subfamily", 
    "Genus", "Subgenus", "Species", "Exemplar GenBank Accession Number", 
    "Exemplar virus name", "Virus name abbrevn", "Exemplar isolate designation", 
    "Genome coverage", "Genome composition", "Host/Source", "Change", 
    "Rank", NA_character_, NA, NA, NA, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_)
xlsx_v2_row3=c(
    "Realm", "Subrealm", "Kingdom", "Subkingdom", "Phylum",
    "Subphylum", "Class", "Subclass", "Order", "Suborder", 
    "Family", "Subfamily", "Genus", "Subgenus", "Species",
    "Realm", "Subrealm", "Kingdom", "Subkingdom", "Phylum",
    "Subphylum","Class", "Subclass", "Order", "Suborder", 
    "Family", "Subfamily","Genus", "Subgenus", "Species",
    "Exemplar GenBank Accession Number", 
    "Exemplar \r\nvirus name",
    "Virus name abbreviation", 
    "Exemplar\r\nisolate designation", 
    "Genome coverage", 
    
    "Genome composition", 
    "Host/Source", 
    "Change", 
    "Rank",
    "Comments"
    )

#
# load .xlsx file into DF
#
load_proposal = function(id) {
  # read XLSX file, no column names
  df = data.frame(
    read_excel(
      proposals[id,"xlsx"],
      trim_ws = TRUE,
      na = "Please select",
      skip = 2,
      range = cell_cols("A:AO"),
      col_names = FALSE
    )
  )
  # return value
  return(df)
}

#
# QC the .xlsx data at the sheet level
#
# returns: errorDf
addError=function(errorDf,id,levelStr,errorStr,notes) {
  nextErrorDf = data.frame(
    folder = proposals[id,]$folder,
    id = id,
    docx = proposals[id,]$docx,
    xlsx = proposals[id,]$xlsx,
    level = levelStr,
    message = errorStr, 
    notes = notes)
  return(rbind(errorDf,nextErrorDf))
}

qc_proposal = function(id, proposalDf) {
  # set up error tracking
  errorDf = allErrorDf[FALSE,]
  templateVersion = "unknown"
  
  # check row 2 to validate version of templates
  row2v1match = sum(proposalDf[2, seq(from = 2, to = min(length(xlsx_v1_row2) +
                                                           1, ncol(proposalDf)))] == xlsx_v1_row2, na.rm = T)
  row2v2match = sum(proposalDf[2, seq(from = 2, to = min(length(xlsx_v2_row2) +
                                                           1, ncol(proposalDf)))] == xlsx_v2_row2, na.rm = T)
  if (row2v1match == sum(!is.na(xlsx_v1_row2))) {
    return(addError(errorDf,id,"ERROR", "XLSX.line2 is V1",""))
  } else if (row2v2match == sum(!is.na(xlsx_v2_row2))) {
    cat("     ", id, " Row 2: V2 template\n")
    templateVersion = "v2"
  } else {
    return(addError(errorDf,id,"ERROR", "XLSX.line2 is not recognized",""))
  }
  
  # check row 3 to validate version of templates
  row3v1match = sum(proposalDf[3, seq(from = 2, to = min(length(xlsx_v1_row3) +
                                                           1, ncol(proposalDf)))] == xlsx_v1_row3)
  row3v2match = sum(proposalDf[3, seq(from = 2, to = min(length(xlsx_v2_row3) +
                                                           1, ncol(proposalDf)))] == xlsx_v2_row3)
  if (row3v1match == length(xlsx_v1_row3)) {
    return(addError(errorDf,id,"ERROR", "XLSX.line3 is V1",""))
  } else if (row3v2match == length(xlsx_v2_row3)) {
    cat("     ", id, " Row 3: V2 template\n")
    if (templateVersion != "v2") {
      return(addError(errorDf,id,"ERROR",paste("XLSX.line3 is v2, but line2 is", templateVersion)))
    }
  } else {
    return(addError(errorDf,id,"ERROR", "XLSX.line2 is not recognized",""))
  }
  
  #
  # QC V2
  #
  if( templateVersion == "v2" ) {
    # check proposal ID
    if( proposalDf[3,1] != id ) {
      errorDf=addError(errorDf,id,"WARNING", "XLSX.cellA3 does not match proposal code from filename", 
                       paste0("'",proposalDf[3,1], "' should be '", id,"' ")
                       )
    }
  }
  # return errors, if any
  return(errorDf)
}
```

# Load and Process

```{r load_and_process}

for( id in head(rownames(proposals),n=20) ) {
  #
  # load
  #
  proposalDf = load_proposal(id)
  cat("# LOADED: ",id,"\n")
  #
  # qc
  #
  errorDf = qc_proposal(id,proposalDf)
  cat("# QCed: ",id," with ",nrow(errorDf)," errors/warnings\n")
  if(nrow(errorDf)>0){allErrorDf=rbind(allErrorDf,errorDf)}
}

# error summary
allErrorDf=rbind(allErrorDf,errorDf)
write_xlsx(x=allErrorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))
kable(allErrorDf,caption = paste0("QC: Summary of ERRORs and WARNINGs"))

```


```
