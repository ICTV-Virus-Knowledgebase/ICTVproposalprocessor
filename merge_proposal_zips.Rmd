---
title: "ICTV validate proposals"
params:
  # inputs
  prev_msl: 37
  next_msl: 38
  taxnode_delta: 100000
  prev_taxa_fname: ./current_msl/taxonomy_node_names.all.txt
  db_rank_fname: ./current_msl/taxonomy_level.txt
  db_molecule_fname: ./current_msl/taxonomy_molecule.txt
  cv_xlsx: ./TP_Template_Excel_module_2022_v2.xlsx
  cv_sheet: "Menu Items (Do not change)"
  templateURL: "https://ictv.global/taxonomy/templates"
  proposals_dir: ./proposals
  out_dir: ./results
  # output files
  dest_msl: 38
  merged:  load_next_msl.txt
  status:  merged_status.txt
  # debug output: 0=none, 1=some, 2=details
  verbose: 1
  
output: html_document
---

QC MSL38: https://uab-lefkowitz.atlassian.net/browse/IVK-123
Merge++:  https://uab-lefkowitz.atlassian.net/browse/IVK-22

<<<<<<<<<<
<< NEXT >>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  * RE_ORG to separate scan/load from process
     * make it easy to re-process - move globals to process section
     
  * finish attributes on create taxa
    * build new lineage from parent lineage+destTaxonName!
    * left_right index?
  * rename
  * split
  * promote
  * demote
  * merge
  
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
CURRENT STATUS:
  * loads and correlates XLSX/DOCX
  * prevMSL, curMSL and newMSL all converted to data.frame

This script 
  * load previous MSL data into a data frame
  * scans params$ ./proposals for *.(xlsx|docx) (proposals)
  * iterates over each proposal .xlsx
    * reads the proposal.xlsx file into a data table 
    * merge each row (change)
      * match up to existing taxon
      * QC data, etc.
      * implement change in new MSL data frame
      * record errors, warnings, etc
      * create merged change set in one merged dataframe
  * write merged proposal data frame to a Unicode(UTF-16LE) TSV file (params$merged) that can be loaded into MSSQL on Windows using "Import Data...." 
  * write a status sheet listing parsing and QC success/fail status for each proposal (params$status)
  * write new MSL load & updates to prev_msl.out_*
  
```{r setup, include=FALSE}


#
# WARNING: we use data.TABLE instead of data.FRAME
#
# this allows modification in place of a (data) passed
# to a subroutine (pass-by-reference feature)
library(data.table)

library(yaml)
library(tidyverse)
library(readxl)
library(writexl) # another option library(openxlsx)
#library(gtools) # for mixedsort/mixedorder

library(knitr) #kable
# debug - echo everything
knitr::opts_chunk$set(echo = TRUE)

```


# function to copy prev MSL to new MSL

```{r function_copy_prev_msl_to_new_msl, echo=FALSE}

#
# this uses the DATABASE schema for the taxonomy_node table (ie, naming convention)
#
# extra admin fields added, which wont be saved
#   prev_taxnode_id
#   prev_proposals
#
createNewMSL = function(curMSL,prev_msl,dest_msl,taxnode_delta) {
  # curMSL = curMSL; prev_msl=params$prev_msl; dest_msl=params$next_msl; taxnode_delta=params$taxnode_delta

  #
  # copy previous years MSL rows to create a basis for this years
  #
  # copies the rows having msl_release_num=prev_msl and offsets all their taxnode_id (and FK(taxnode_id) columns by (taxnode_delta)
  #
  # copy the rows
  newMSL=copy(subset(curMSL, msl_release_num==prev_msl))
  
  #
  # add some admin rows
  #
  
  # copy original taxnode_id's into a new column
  newMSL[,"prev_taxnode_id"] = newMSL[,"taxnode_id"]
  
  # CSV of proposals that have already modified this taxon in this MSL
  newMSL[,"prev_proposals"] = NA_character_
  
  #
  # update all ids (taxnode_id and all FK's to taxnnode_id) for new MSL
  #
  
  # update the node ids
  fkTaxnodeIdCols = c("taxnode_id","parent_id","tree_id",
                 paste0(tolower(
                   c("Realm", "Subrealm", "Kingdom", "Subkingdom", 
                     "Phylum", "Subphylum", "Class", "Subclass", "Order", "Suborder", 
                     "Family", "Subfamily", "Genus", "Subgenus", "Species")),"_id")
  )
  newMSL[,(fkTaxnodeIdCols) := lapply(.SD, function(id) id+params$taxnode_delta),.SDcols=fkTaxnodeIdCols]
  
  # update the MSL number
  newMSL[,msl_release_num:=dest_msl]
  
  # make row ids match
  #rownames(newMSL) = newMSL$taxnode_id
  
  # clear in/out changes
  clearCols = c(grep(names(newMSL),pattern="^(in|out)_",value=T))
  newMSL[,(clearCols) := NA]
  
  # add the new rows
  #return(rbind(taxonomy_node, newMSL))
  return(newMSL)
}

#
# get next available taxnode_id in a given MSL
#
assignNextTaxnodeId = function(taxonomy_node,msl) {
  return(max(subset(taxonomy_node,msl_release_num==msl)$taxnode_id)+1)
  
}
```
# load previous MSLs
```{r load prev MSL, echo=F}

#
# this uses the DATABASE schema for the taxonomy_node table (ie, naming convention)
#

taxonomy_node_names = c(
  taxnode_id="integer",parent_id="integer",tree_id="integer",msl_release_num="integer",level_id="integer",
  name="character",
  ictv_id="integer",molecule_id="integer",
  abbrev_csv="character",genbank_accession_csv="character",genbank_refseq_accession_csv="character",refseq_accession_csv="character",isolate_csv="character",notes="character",
  is_ref="factor",is_official="factor",is_hidden="factor",is_deleted="factor",is_deleted_next_year="factor",is_typo="factor",is_renamed_next_year="factor",
  is_obsolete="factor",
  in_change="factor",in_target="character",in_filename="character",in_notes="character",
  out_change="factor",out_target="character",out_filename="character",out_notes="character",
  start_num_sort="integer",
  row_num="integer",filename="character",xref="character",
  realm_id="integer",realm_kid_ct="integer",realm_desc_ct="integer",
  subrealm_id="integer",subrealm_kid_ct="integer",subrealm_desc_ct="integer",
  kingdom_id="integer",kingdom_kid_ct="integer",kingdom_desc_ct="integer",
  subkingdom_id="integer",subkingdom_kid_ct="integer",subkingdom_desc_ct="integer",
  phylum_id="integer",phylum_kid_ct="integer",phylum_desc_ct="integer",
  subphylum_id="integer",subphylum_kid_ct="integer",subphylum_desc_ct="integer",
  class_id="integer",class_kid_ct="integer",class_desc_ct="integer",
  subclass_id="integer",subclass_kid_ct="integer",subclass_desc_ct="integer",
  order_id="integer",order_kid_ct="integer",order_desc_ct="integer",
  suborder_id="integer",suborder_kid_ct="integer",suborder_desc_ct="integer",
  family_id="integer",family_kid_ct="integer",family_desc_ct="integer",
  subfamily_id="integer",subfamily_kid_ct="integer",subfamily_desc_ct="integer",
  genus_id="integer",genus_kid_ct="integer",genus_desc_ct="integer",
  subgenus_id="integer",subgenus_kid_ct="integer",subgenus_desc_ct="integer",
  species_id="integer",species_kid_ct="integer",species_desc_ct="integer",
  taxa_kid_cts="character",taxa_desc_cts="character",
  inher_molecule_id="integer",left_idx="integer",right_idx="integer",node_depth="integer",
  lineage="character",
  cleaned_name="character",cleaned_problem="character",flags="character",
  "_numKids"="integer","_out_target_parent"="factor","_out_target_name"="factor",
  rank="factor",tree="factor",
  realm="factor",subrealm="factor",kingdom="factor",subkingdom="factor",phylum="factor",subphylum="factor",class="factor",subclass="factor",order="factor",suborder="factor",family="factor",subfamily="factor",genus="factor",subgenus="factor",species="factor",
  molecule="factor",inher_molecule="factor"
  )
#taxonomyDf=read.delim(file=params$prev_taxa_fname,header=FALSE,col.names=names(taxonomy_node_names),stringsAsFactors=FALSE,na.strings="NULL")
taxonomyDt=fread(file=params$prev_taxa_fname,
                 header=FALSE,col.names=names(taxonomy_node_names),colClasses=as.character(taxonomy_node_names),
                 stringsAsFactors=FALSE,na.strings=c("","NULL"))
cat("Previous taxa:",dim(taxonomyDt), " from ",params$prev_taxa_fname,"\n")


```

# load db CV tables 
```{r load db cv tables, echo=F}
#
# this uses the DATABASE schema for the taxonomy_node table (ie, naming convention)
#

# DB CV loads
dbCvList = list()
dbCvMapList = list()

rankCV = read.delim(file=params$db_rank_fname,header=TRUE, stringsAsFactors=TRUE,na.strings=c("NULL"))
rownames(rankCV) = rankCV$id
cat("RankCV: ", dim(rankCV), " from ",params$db_rank_fname,"\n")
dbCvList[["rank"]] = rankCV
dbCvMapList[["rank"]] = rankCV$id
names(dbCvMapList[["rank"]]) = rankCV$name


moleculeCV = read.delim(file=params$db_molecule_fname,header=TRUE, stringsAsFactors=TRUE,na.strings=c("NULL"))
rownames(moleculeCV) = moleculeCV$id
cat("MoleculeCV: ", dim(moleculeCV), " from ",params$db_molecule_fname,"\n")
dbCvList[["molecule"]] = moleculeCV
dbCvMapList[["molecule"]] = moleculeCV$id
names(dbCvMapList[["molecule"]]) = moleculeCV$abbrev

```
# Load CVs for Proposal QC
```{r load cvs}

#
# this uses the PROPOSAL.XLSX schema (naming convention)
#

proposalCV = suppressMessages(data.frame(read_excel(params$cv_xlsx,sheet = params$cv_sheet,col_names = FALSE)))
#cvDf = data.f rame(trib[,])  # remove "select one" line

cvList=list()
for(cv_col in 1:ncol(proposalCV)) {
  cv_name = proposalCV[1,cv_col]
  cv = proposalCV[,cv_col][-1]
  cvList[[cv_name]]=c(cv[!is.na(cv)],NA)
}

# map to actual input xlsx column names
cvNameMap = c(
  "Genome coverage"=    "genomeCoverage",
  "Genome composition"= "molecule",
  "Host/Source"=        "hostSource",
  "Change"=             "change",
  "Rank"=               "rank"  
)
names(cvList)=cvNameMap[names(cvList)]

# remove ("Please select",NA) from "change" & "rank" CVs - that is a required field
for( cv in c("change","rank") ) {
  isRemoveTerm = cvList[[cv]] %in% c("Please select",NA) 
  cvList[[cv]] = cvList[[cv]][!isRemoveTerm]
}

#
# add XLS terms be aliases to DB ID maps
#
cv = "molecule"
isOk = 
  # things that match after removing spaces
  gsub(pattern=" ",replacement="",x=cvList[[cv]]) %in% names(dbCvMapList[[cv]]) &
  # things that DON'T match exactly
  !cvList[[cv]] %in% names(dbCvMapList[[cv]])

aliases = dbCvMapList[["molecule"]][gsub(pattern=" ",replacement="",x=cvList[["molecule"]])[isOk]]
names(aliases) = cvList[[cv]][isOk]
# add aliases
dbCvMapList[[cv]] = c(
  # original map
  dbCvMapList[[cv]],
  # additional aliases
  aliases,
  # hack for "multiple" which was in xlsx, but doesn't map to the db
  "multiple"=NA
  )
  
```

# scan for proposal .xlsx files
```{r scan for proposal matching xlsx and docx}
# 
# error reporting data frame
# 
allErrorDf = data.table(
  "folder" = character(),
  "code" = character(),
  "docx" = character(),
  "xlsx" = character(),
  "row"  = integer(),
  "level" = factor(levels=c("ERROR","WARNING","INFO")),
  "error" = character(),
  "message" = character(),
  "notes" = character()
)
dir.create(params$out_dir,recursive=T,showWarnings = F)

#
# scan DOCX
#
# break filename into proposal code, filenaem and folder name
#
proposals = data.frame(docxpath=list.files(path="proposals",pattern="20[0-9][0-9].[0-9A-Z]+.*.v*.*.docx", recursive=T, full.names=TRUE) )
proposals$folder   = gsub(".*/([^/]+)/(20[0-9]+.[0-9A-Z]+).[^/]+.docx$","\\1",proposals$docxpath)
proposals$code     = gsub(".*/([^/]+)/(20[0-9]+.[0-9A-Z]+).[^/]+.docx$","\\2",proposals$docxpath)
proposals$basename = gsub(".*/([^/]+)/(20[0-9]+.[0-9A-Z]+.[^/]+).docx$","\\2",proposals$docxpath)
proposals$docx     = paste0(proposals$basename,".docx")

# check for duplicate Proposal IDs
dups = duplicated(proposals$code)
allDups =proposals$code %in% proposals$code[dups]
if(sum(dups) > 0) {
  errorDf = proposals[allDups, c("folder", "code", "docx")]
  errorDf$level = "ERROR"
  errorDf$error = "DUPCODE.DOCX"
  errorDf$message = "duplicate proposal ID"
  allErrorDf = rbindlist(list(allErrorDf, errorDf),fill=TRUE)
  # output
  kable(errorDf,caption = paste0("QC01: ERRORS: dupliate docx proposal IDs"))
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC01.docx_duplicate_ids.xlsx"))
  write_xlsx(x=allErrorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))

}
rownames(proposals)=proposals$code

#
# scan XLSX
#
xlsxs = data.frame(xlsxpath=list.files(path="proposals",pattern="20[0-9][0-9].[^.]+.*.v*.*.xlsx", recursive=T, full.names=TRUE) )
xlsxs$folder   = gsub(".*/([^/]+)/(20[0-9]+.[0-9A-Z]+).[^/]+.xlsx$","\\1",xlsxs$xlsxpath)
xlsxs$basename = gsub(".*/([^/]+)/(20[0-9]+.[0-9A-Z]+.[^/]+).xlsx$","\\2",xlsxs$xlsxpath)
xlsxs$code     = gsub(".*/([^/]+)/(20[0-9]+.[0-9A-Z]+).[^/]+.xlsx$","\\2",xlsxs$xlsxpath)
xlsxs$xlsx     = paste0(xlsxs$basename,".xlsx")

# ignore "Suppl" files 
sups = grep(xlsxs$xlsx,pattern="_Suppl." )
xlsxs=xlsxs[-(sups),]

# QC for duplicate codes
dups = duplicated(xlsxs$code)
allDups =xlsxs$code %in% xlsxs$code[dups]
if( sum(dups) > 0 ) {
  errorDf = xlsxs[allDups, c("folder", "code", "xlsx")]
  errorDf$level = "ERROR"
  errorDf$error = "DUPCODE.XLSX"
  errorDf$message = "duplicate proposal ID"
  allErrorDf = rbindlist(list(allErrorDf, errorDf),fill=TRUE)
  # output
  kable(errorDf,caption = paste0("QC01: ERRORS: dupliate docx proposal IDs"))
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC01.docx_duplicate_ids.xlsx"))
  write_xlsx(x=allErrorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))

  kable(caption=paste0("ERROR: XLSX dupliate proposal IDs"),
        x=proposals[proposals$code %in% proposals$code[dups],])
}
rownames(xlsxs) = xlsxs$basename

#
# merge XLSX list into DOCX list, verify
#
proposals$xlsx = xlsxs[proposals$basename,"xlsx"]
proposals$xlsxpath = xlsxs[proposals$basename,"xlsxpath"]
missing= is.na(proposals$xlsx)
if( sum(missing) > 0 ) {
  errorDf= proposals[missing,c("folder","code","docx")]
  # suggest possible matches based on ID
  errorDf$xlsx= NA 
  errorDf$row = NA
  errorDf$level= "ERROR"
  errorDf$error = "MISS.XLSX"
  errorDf$message = "DOCX has no matching XLSX"
  errorDf$notes= "Suggestions: none"
  for(row in rownames(errorDf) ) {
    guesses = sum(xlsxs$code==errorDf[row,"code"])
    if( guesses == 1 ) { 
      # if we have a unique guess, then make it a WARNING, and use that guess
      proposals[row,"xlsx"]=xlsxs[xlsxs$code==errorDf[row,"code"],"xlsx"]
      errorDf[row,]$xlsx = proposals[row,"xlsx"]
      errorDf[row,]$row = NA
      errorDf[row,]$level = "WARNING"
      errorDf[row,]$error = "APROX.XSLX"
      errorDf[row,]$notes = paste("Using best guess:",proposals[row,"xlsx"])
    } else if( guesses > 1 ) {
      # just list all the options we found
      errorDf[row,"notes"] = paste("SUGGESTIONS:",paste(paste0(xlsxs[xlsxs$xlsxID==errorDf[row,"docxID"],"basename"],".xslx"),collapse=", "))
    }
  }
  # QC output
  kable(errorDf,caption = paste0("QC02: ERRORS: DOCX without matching XLSX"))
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC02.docx_without_matching_xlsx.xlsx"))
  allErrorDf=rbindlist(list(allErrorDf,errorDf),fill=TRUE)
  write_xlsx(x=errorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))

  }
```

# Load summary

```{r load_summary,echo=FALSE}
kable(caption=paste0("SUMMARY: Proposal .xlsx file found in ",params$proposals_dir,"/"),
      x=data.frame(nProposals=summary(as.factor(proposals$folder))),)
```

## QC setup
```{r qc_setup_template_versions, echo=TRUE}


#
# this uses the PROPOSAL.XLSX schema (naming convention)
#

# dput(unname(as.vector(df[1,])))
xlsx_v1_row2=c(
    "CURRENT TAXONOMY", NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, "PROPOSED TAXONOMY", NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, "SPECIFY PROPOSED CHANGE", NA_character_, 
    "COMMENTS", NA, NA, NA, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_
    )

xlsx_v2_row2=c(
    "CURRENT TAXONOMY", NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    "PROPOSED TAXONOMY", NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, 
    NA_character_, NA_character_, NA_character_, "SPECIFY PROPOSED CHANGE", NA_character_, 
    "COMMENTS"
    )

# dput(unname(as.vector(df[2,])))
xlsx_row3_v1=c(
  "Realm", "Subrealm", "Kingdom", "Subkingdom", 
  "Phylum", "Subphylum", "Class", "Subclass", "Order", "Suborder", 
  "Family", "Subfamily", "Genus", "Subgenus", "Species",
  # V1 only, removed in V2
  "Exemplar GenBank Accession Number", 
  "Realm", "Subrealm", "Kingdom", "Subkingdom", "Phylum", "Subphylum", 
  "Class", "Subclass", "Order", "Suborder", "Family", "Subfamily", 
  "Genus", "Subgenus", "Species",
  "Exemplar GenBank Accession Number", 
  "Exemplar \r\nvirus name",
  "Virus name abbrevn", 
  "Exemplar\r\nisolate designation", 
  "Genome coverage", 
  "Genome composition", 
  "Host/Source", 
  "Change", 
  "Rank"
)
xlsx_row3_v2=c(
  # V2 added column
  Code=NA_character_, 
  "Realm", "Subrealm", "Kingdom", "Subkingdom",
  "Phylum","Subphylum", "Class", "Subclass", "Order", "Suborder", 
  "Family", "Subfamily", "Genus", "Subgenus", "Species",
  "Realm", "Subrealm", "Kingdom", "Subkingdom", "Phylum","Subphylum",
  "Class", "Subclass", "Order", "Suborder", "Family", "Subfamily",
  "Genus", "Subgenus", "Species",
  "Exemplar GenBank Accession Number", 
  "Exemplar \r\nvirus name", 
  "Virus name abbreviation", 
  "Exemplar\r\nisolate designation", 
  "Genome coverage", 
  "Genome composition", 
  "Host/Source", 
  "Change", 
  "Rank",
  # V2 added column
  "Comments"
)

#
# changeDf column names
#
# this is the mapped subset of columns pulled from the proposal
# normalized across XSLX template versions
#
xlsx_change_ranks=c("Realm", "Subrealm", "Kingdom", "Subkingdom", 
    "Phylum", "Subphylum", "Class", "Subclass", "Order", "Suborder", 
    "Family", "Subfamily", "Genus", "Subgenus", "Species"
    )

# record mapping of V2 column names to generic v1/v2 merged, cleaned names
xlsx_change_other=c( 
  "Exemplar GenBank Accession Number" = "exemplarAccession", 
  "Exemplar \r\nvirus name"           = "exemplarName", 
  "Virus name abbreviation"           = "Abbrev", 
  "Exemplar\r\nisolate designation"   = "exemplarIsolate", 
  "Genome coverage"                   = "genomeCoverage", 
  "Genome composition"                = "molecule",   # Genome Composition", 
  "Host/Source"                       = "hostSource",
  "Change"                            = "change",
  "Rank"                              = "rank",
  "Comments"                          = "comments"
)
xlsx_change_colnames = c(  
  paste0("src",xlsx_change_ranks), # 1:15
  tolower(xlsx_change_ranks),      # 16:30
  xlsx_change_other )              # 31:39

xlsx_change_srcCols = c(1:15)
xlsx_change_destCols = c(16:30)

#
# regex patterns to recognize illegal cell content
#
xlsx_col_info = data.frame(row.names=xlsx_change_colnames,
                           pattern = rep(NA_character_,length(xlsx_change_colnames)),
                           pat_warn = rep(NA_character_,length(xlsx_change_colnames))
                           )
# most taxa can only be alphanumeric plus a hyphen
xlsx_col_info[c(xlsx_change_colnames[c(xlsx_change_srcCols,xlsx_change_destCols)],"rank"),"pattern"] = "([^[:alnum:]-]+)"
xlsx_col_info[c(xlsx_change_colnames[c(xlsx_change_srcCols,xlsx_change_destCols)],"rank"),"pat_warn"] = "non-(AlphaNumeric or hyphen)"
xlsx_col_info[c(xlsx_change_colnames[c(xlsx_change_srcCols,xlsx_change_destCols)],"rank"),"pat_code"] = "XLSX.NON_ALPHA-NUMERIC"
# allow internal spaces on species and columns with lists/isolate names
xlsx_col_info[c("srcSpecies","species","change"),"pattern"] = "([^[:alnum:] -]+)"
xlsx_col_info[c("srcSpecies","species","change"),"pat_warn"] = "non-(AlphaNumeric or hyphen or space)"
xlsx_col_info[c("srcSpecies","species","change"),"pat_code"] = "XLSX.NON_ALPHA-NUMERIC-SPACE)"
# lists
xlsx_col_info[c( "exemplarAccession","exemplarName","Abbrev","exemplarIsolate"),"pattern"] = "([^[:alnum:],:;_/ -]+)"
xlsx_col_info[c( "exemplarAccession","exemplarName","Abbrev","exemplarIsolate"),"pat_warn"] = "non-(AlphaNumeric or punctuation)"
xlsx_col_info[c( "exemplarAccession","exemplarName","Abbrev","exemplarIsolate"),"pat_code"] = "XLSX.NON-ALPHA-NUM-LIST"
# others just must be printable
xlsx_col_info[is.na(xlsx_col_info$pattern),"pattern"] = "(^[:print:]+)"
xlsx_col_info[is.na(xlsx_col_info$pat_warn),"pat_warn"] = "unprintable/non-ASCII"
xlsx_col_info[is.na(xlsx_col_info$pat_warn),"pat_code"] = "XLSX.NON_PRINTABLE"

#
# map xlsx VERSION columns to normalized "Change" columns
#
xlsx_v1_change_cols = c(
  1:15,  # srcRanks
  17:31, # dest Ranks
  32:41  # other
)
xlsx_v2_change_cols = c(
  2:16,  # srcRanks
  17:31, # dest Ranks
  32:41  # other
)
```

# QC functions

```{r qc_functions_defined, echo=FALSE}

#
# this uses the PROPOSAL.XLSX schema (naming convention)
#

#
# load .xlsx file into DF
#
load_proposal = function(id) {
  # read XLSX file, no column names
  df = data.frame(
    # suppress errors about column names
    # https://github.com/tidyverse/readxl/issues/580#issuecomment-519804058
    suppressMessages(
      read_excel(
        proposals[id,"xlsxpath"],
        trim_ws = TRUE,
        na = "Please select",
        skip = 2,
        range = cell_cols("A:AO"),
        col_names = FALSE
      )
    )
  )
  # return value
  return(df)
}

#
# QC the .xlsx data at the sheet level
#
# returns: errorDf
addError=function(errorDf,code,row,levelStr,errorCode,errorStr,notes) {
  nextErrorDf = data.frame(
    folder = proposals[code,]$folder,
    code = code,
    row = row,
    docx = proposals[code,]$docx,
    xlsx = proposals[code,]$xlsx,
    level = levelStr,
    error = errorCode,
    message = errorStr, 
    notes = notes)
  return(rbind(errorDf,nextErrorDf))
}

# id="2022.003S"; proposalDf=load_proposal(id) # V1 template
# id="2022.002S"; proposalDf=load_proposal(id) # V2 template
# id="2022.015M"; proposalDf=load_proposal(id) # line 5 hostSource invalid chars? 
qc_proposal = function(code, proposalDf) {
  # set up error tracking
  errorDf = allErrorDf[FALSE,]
  templateVersion = "error"
  
  # check row 2 to validate version of templates
  row2v1match = sum(proposalDf[2, seq(from = 1, to = min(length(xlsx_v1_row2), ncol(proposalDf)))] == xlsx_v1_row2, na.rm = T)
  row2v2match = sum(proposalDf[2, seq(from = 2, to = min(length(xlsx_v2_row2) +
                                                           1, ncol(proposalDf)))] == xlsx_v2_row2, na.rm = T)
  if (row2v1match == sum(!is.na(xlsx_v1_row2))) {
    templateLine2Version = "v1"
  } else if (row2v2match == sum(!is.na(xlsx_v2_row2))) {
    templateLine2Version = "v2"
  } else {
    templateLine2Version = "unrecognized"
  }
  if(params$verbose>1) { cat("     ", code, " XLSX.Row 2: ",templateLine2Version,"\n")}
  
  # check row 3 to validate version of templates
  row3v1match = sum(proposalDf[3, seq(from = 1, to = min(length(xlsx_row3_v1), ncol(proposalDf)))] == xlsx_row3_v1, na.rm=T)
  row3v2match = sum(proposalDf[3, seq(from = 1, to = min(length(xlsx_row3_v2), ncol(proposalDf)))] == xlsx_row3_v2, na.rm=T)
  if (row3v1match == sum(!is.na(xlsx_row3_v1))) {
    templateLine3Version = "v1"
  } else if (row3v2match == sum(!is.na(xlsx_row3_v2))) {
    templateLine3Version = "v2"
  } else {
    templateLine3Version = "unrecognized"
  }
  if(params$verbose>1){cat("     ", code, " XLSX.Row 3: ",templateLine3Version,"\n")}
  
  # check for row2/row3 mismatch or errors
  if (templateLine2Version != templateLine2Version || "unrecognized" %in% c(templateLine2Version,templateLine3Version)) {
    
    proposals[code,"templateVersion"]="error"   
    errorDf=addError(errorDf,code,3,"ERROR","XLSX template version",paste0("ROW2 is ",templateLine2Version,
                                                                      ", ROW3 is ", templateLine3Version))
       return(list(errorDf=errorDf))
  } else {
    templateVersion = templateLine2Version
  }
  # finish up templateVersion
  proposals[code,"templateVersion"]=templateVersion
  if( templateVersion == "v1") {
    # WARNING for outdated templates
    errorDf=addError(errorDf,code,3,"WARNING","OLD_TEMPL1", "XLSX template version",
                     paste0("You are using version ",templateVersion,". Please get the latest version from ",params$templateURL)
    )
  }
  if(params$verbose){cat("     ", code, " XLSX template ",templateVersion,"\n")}
  
  #
  # QC Proposal ID
  #
  codeValue="missing" 
  codeCell="undefined"
  codeRow = NA
  if( templateVersion == "v1" ) { codeValue= proposalDf[1,1]; codeCell="A1"; codeRow=1 }
  if( templateVersion == "v2" ) { codeValue= proposalDf[3,1]; codeCell="A3"; codeRow=3 }
  if( codeValue != code ) {
    if( str_starts(codeValue,"Code") ) {
      errorDf=addError(errorDf,code,codeRow,"WARNING","CODE_MISS", "XLSX code missing", 
                       paste0("XLSX cell ",codeCell,
                              " is ", "'",codeValue, 
                              "'; replace with the actual code: '",code,"'")
      )
    } else {
      errorDf=addError(errorDf,code,codeRow,"WARNING", "CODE_BAD","XLSX code wrong", 
                       paste0("XLSX cell ",codeCell,
                              " does not match proposal code from filename: ", 
                              "'",codeValue, "' should be '", code,"' ")
      )
    }
  }
  
  #
  # extract & standardize
  # cols&rows with change data 
  #
  changeDf = data.frame()

  # map columns
  firstDataRow=4
  if(templateVersion=="v1") { changeDf = proposalDf[firstDataRow:nrow(proposalDf),xlsx_v1_change_cols] }
  if(templateVersion=="v2") { changeDf = proposalDf[firstDataRow:nrow(proposalDf),xlsx_v2_change_cols] }
  colnames(changeDf) = xlsx_change_colnames
  
  # find non-empty rows
  hasData = apply(changeDf,1,function(r){return(sum(is.na(r))!=length(r))})
  changeDf=changeDf[hasData,]
  if( nrow(changeDf) == 0 ) {
    errorDf=addError(errorDf,code,firstDataRow,"ERROR", "XLSX_EMPTY","XLSX no change rows found", "")
    return(list(errorDf=errorDf))
  } else {
    proposals[code,"nChanges"] = nrow(changeDf)
  }
  
  #
  # QC spaces, quotes, etc
  # 
  # TODO: remove leading/trailing spaces, quotes
  for( col in rownames(xlsx_col_info) ) {
    # col = "srcSpecies" # debug
    #  col = "hostSource" # debug
    
    #
    # leading white space
    #
    pattern="^([ \t]+)"; pat_warn="leading whitespace"
    qc.matches =grep(changeDf[,col],pattern=pattern)
    if(length(qc.matches)>0) { 
      if(params$verbose) { cat("WARNING:",code,"has",length(qc.matches),"cells with",pat_warn,"in column",col,"\n") }
      errorDf=addError(errorDf,code,rownames(changeDf)[qc.matches],
                       "WARNING","XLSX.LEAD_SPACE", paste("XLSX has",pat_warn),
                       paste(col,gsub(pattern,"[\\1]",changeDf[qc.matches,col]),sep=":"))
      # remove non-ascii chars
      changeDf[,col] = gsub(pattern,"",changeDf[,col])
    } 
    #
    # trailing white space
    #
    pattern="([ \t]+)$"; pat_warn="trailing whitespace"
    qc.matches =grep(changeDf[,col],pattern=pattern)
    if(length(qc.matches)>0) { 
      if(params$verbose) { cat("WARNING:",code,"has",length(qc.matches),"cells with",pat_warn,"in column",col,"\n") }
      errorDf=addError(errorDf,code,rownames(changeDf)[qc.matches],
                       "WARNING","XLSX.TRAIL_SPACE", paste("XLSX has",pat_warn),
                       paste(col,gsub(pattern,"[\\1]",changeDf[qc.matches,col]),sep=":"))
      # remove non-ascii chars
      changeDf[,col] = gsub(pattern,"",changeDf[,col])
    } 
    #
    # quotes
    #
    if( col != "comments" ) {
      pattern='(["]+)'; pat_warn="quote"
      qc.matches =grep(changeDf[,col],pattern=pattern)
      if(length(qc.matches)>0) { 
        if(params$verbose) { cat("WARNING:",code,"has",length(qc.matches),"cells with",pat_warn,"in column",col,"\n") }
        errorDf=addError(errorDf,code,rownames(changeDf)[qc.matches],
                         "WARNING","XLSX.QUOTES", paste("XLSX has",pat_warn),
                         paste(col,gsub(pattern,"[\\1]",changeDf[qc.matches,col]),sep=":"))
        # remove non-ascii chars
        changeDf[,col] = gsub(pattern,"",changeDf[,col])
      } 
    }
    # 
    # more rigorous for some columns
    #
    pattern=xlsx_col_info[col,"pattern"]; pat_warn=xlsx_col_info[col,"pat_warn"]
    qc.matches =grep(changeDf[,col],pattern=pattern)
    if(length(qc.matches)>0) { 
      if(params$verbose) { cat("WARNING:",code,"has",length(qc.matches),"cells with",pat_warn,"in column",col,"\n") }
      errorDf=addError(errorDf,code,rownames(changeDf)[qc.matches],
                       "WARNING",xlsx_col_info[col,"pat_code"], paste("XLSX has",pat_warn),
                       paste(col,gsub(pattern,"[\\1]",changeDf[qc.matches,col]),sep=":"))
      # remove non-ascii chars
      changeDf[,col] = gsub(pattern,"",changeDf[,col])
    }
  }  # for col
  
  #
  # QC controlled vocabularies
  #

  # check that all columns are present
  
  missingCvNames = names(cvList)[!names(cvList) %in% names(changeDf)]
  if(length(missingCvNames)>0) {
    if(params$verbose) { cat("ERROR:",code,"missing CV columns [",paste(missingCvNames, collapse=","),"] on row 3\n") }
    errorDf=addError(errorDf,code,3,"ERROR","XLSX.MISSING_COLUMN",paste("XLSX missing column"),
                     paste("XLSX missing header [",missingCvNames,"]")) 
    return(list(errorDf=errorDf))
  }
  #
  # check that all the terms are legal
  #
  # remove lines containing invalid terms
  #
  for(cv in names(cvList)) {
    # cv="genomeCoverage" # debug
    isTermGood = changeDf[,cv] %in% cvList[[cv]]
    badTerms=changeDf[!isTermGood,cv, drop=FALSE]
    if(nrow(badTerms)>0) {
      # complain
      if(params$verbose) { cat("ERROR:",code,"illegel term in CV column '",cv,"':",
                              "[",paste(paste0(rownames(badTerms),":",badTerms[,cv]), collapse=","),"] on rows 3\n") }
      errorDf=addError(errorDf,code,rownames(badTerms),"ERROR","XLSX.INVALID_TERM",paste("XLSX incorrect term in column",cv),
                     paste("XLSX incorrect value [",badTerms[,cv],"]. Valid terms: [",paste0(cvList[[cv]],collapse=","),"]")) 
      # remove offending line
      changeDf = changeDf[isTermGood,]
    } # if badTerms
  } # for cvList
  
  # return warnings, if any
  return(list(errorDf=errorDf,changeDf=changeDf))
}
```


# Load and QC

```{r load_and_qc}


#
# this uses the PROPOSAL.XLSX schema (naming convention)
#

#
# extracted changes
#
changeList = list()

for( code in head(rownames(proposals),n=40) ) {
  # for( code in c("2022.003S","2022.002S")) {  # debug
  # code = "2022.003S" # V1
  # code = "2022.002S" # V2
  #
  # load
  #
  proposalDf = load_proposal(code)
  cat("# LOADED: ",code,"\n")
  #
  # qc
  #
  results = qc_proposal(code,proposalDf)
  errorDf = results[["errorDf"]]
  cat("# QCed: ",code," with ",nrow(errorDf)," errors/warnings\n")
  if(nrow(errorDf)>0){allErrorDf=rbindlist(list(allErrorDf,errorDf),fill=TRUE)}
  changeDf = results[["changeDf"]]
  if(!is.null(changeDf)) {
    changeList[[code]]=changeDf
  }
}
# load summary
cat("changeList: ",paste(names(changeList)),"\n")

# error summary
write_xlsx(x=allErrorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))
kable(allErrorDf,caption = paste0("QC: Summary of ERRORs and WARNINGs"))

```


# process changes function

```{r process_changes_function, echo=FALSE}
#
# this uses the DATABASE schema for the taxonomy_node table (ie, naming convention)
#


getTaxon = function(realmSpecies) {
  # 
  # get the NAME of the lowest ranked taxon
  #
  nonNAs = !is.na(realmSpecies)
  if( sum(nonNAs) > 0 ) {
    return(realmSpecies[max(which(nonNAs))])
  } else {
    return(NA)
  }
}
getParentTaxon = function(realmSpecies) {
  #
  # get the NAME of the penultimate low ranked taxon
  #
  nonNAs = !is.na(realmSpecies)
  if( sum(nonNAs) > 1 ) {
    return(realmSpecies[sort(which(nonNAs),decreasing=T)[2]])
  } else {
    return(NA)
  }
}
getLineage = function(realmSpecies,masks=c()) {
  #   
  # concat with ; all non-NA ranks, except those in masks
  #
  nonNAs = !is.na(realmSpecies)
  # is a matrix, rows=taxon, columns=ranks
  nonNAs[,masks] = FALSE
  if( sum(nonNAs) > 0 ) {
    return(paste0(realmSpecies[nonNAs],collapse=";"))
  } else {
    return(NA)
  }
}
getTaxonRank = function(realmSpecies) {
  nonNAs = !is.na(realmSpecies)
  if( sum(nonNAs) > 0 ) {
  # 
  # get the rank of the lowest-rank taxon 
  #
    return(as.character(rankCV$name[max(which(nonNAs))+1]))
  } else {
    return(NA)
  }
}
 
#
# This uses changes (in the PROPOSAL.XLSX schema) to make changes (one per line)
# to the curMSL (in the database taxonomy_node table schema)
#

# excel                                # R.changeDf                             # db.load_next_msl          # db.taxonomy_node          # R.newMSL
#  "Exemplar GenBank Accession Number" = "exemplarAccession",                   "exemplarAccession"         "genbank_accession_csv"     "genbank_accession_csv"
#  "Exemplar \r\nvirus name"           = "exemplarName",                        "exemplarName"              NA                          "exemplar_name"
# "Virus name abbreviation"            = "Abbrev",                              "Abbrev"                    "abbrev_csv"                "abbrev_csv"
# "Exemplar\r\nisolate designation"    = "exemplarIsolate",                     "exemplarIsolate"           "isolate_csv"               "isolate_csv"
# "Genome coverage"                    = "genomeCoverage",                      "isComplete"                NA                          "genome_coverage"
# "Genome composition"                 = "molecule",                            "molecule"                  "molecule_id"               "molecule_id"
# "Host/Source"                        = "hostSource",                          "hostSource"                NA                          "host_source"
# "Change"                             = "change",                              "change","_action"          "in_change","out_change"    "in_change", "out_change"(prevMSL)
# "Rank"                               = "rank",                                "rank","_dest_taxon_rank"   "level_id"                  "level_id"
# "Comments"                           = "comments"                             "comments"                  NA                          "comments"

# map XLSX column names to DB column names
xlsx2dbMap = c(
      "exemplarAccession"="genbank_accession_csv"
      # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
      ,"exemplarName" = "exemplar_name"
      ,"Abbrev"="abbrev_csv"
      # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
      ,"exemplarIsolate"="isolate_csv"
      # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
      ,"genomeCoverage"="genome_coverage"
      # genomeComposition = molecule_id 
      ,"molecule" = "molecule_id"
      # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
      ,"hostSource" = "host_source"
      ,"rank" = "level_id"
      ,"comments" = "comments"
  )

  

apply_changes = function(code,proposalBasename,changeDf) {
  # proposalBasename=proposals[code,"basename"]; proposalBasename # debug

  proposalZip = paste0(proposalBasename,".zip")
  #
  # iterate over changes
  # 
  errorDf = allErrorDf[FALSE,]
  
  # action mappings - externalize or move up
  actionCV = c(
    "create" = "create"
    , "create new" = "create"
    ,"rename" = "rename"
    ,"abolish" = "abolish"
  )
  
  for(linenum in rownames(changeDf)) {
    # linenum = rownames(changeDf)[1] ; linenum; changeDf[linenum,"change"];# debug
    # linenum = rownames(changeDf)[63] ; linenum; changeDf[linenum,"change"];# debug
    # linenum = rownames(changeDf)[which(linenum==rownames(changeDf))+1]; linenum # debug: next row
    # get this change's line
    change = changeDf[linenum,]
    action = change$change
    
    #
    # check CVs
    #

    # clean action
    actionClean = actionCV[tolower(action)]
    if( is.na(actionClean) ) { 
      errorDf = addError(errorDf,code,linenum,"ERROR","ACTION.UNK","Unknown action/change",action)
      next;
    }
    
   
    # rank
    isRankOk = tolower(change$rank) %in% rankCV$name
    if( !isRankOk ) {
        errorDf=addError(errorDf,code,linenum, "WARNING", "RANK.UNK", "Rank name unknown", 
                         paste0("XLSX ROW ",linenum,
                                ", rank=", change$rank, 
                                "; knownRanks=", paste(rankCV$name[-1],collapse = ","))
        )
   
    }
    
    # linenum = rownames(changeDf)[1] # debug
    srcRealmSpecies = change[xlsx_change_srcCols]
    destRealmSpecies = change[xlsx_change_destCols]
    
    # should these be a vector operation, adding columns to changeDF? 
    # if we do that, we need to separate srcTaxon's label (rank) and value (name)
    srcTaxonName  =getTaxon(srcRealmSpecies)
    srcTaxonRank  =getTaxonRank(srcRealmSpecies)
    srcLineage    =getLineage(srcRealmSpecies)
    destTaxonName =getTaxon(destRealmSpecies)
    destTaxonRank =getTaxonRank(destRealmSpecies)
    destParentName=getParentTaxon(destRealmSpecies)
    destLineage   =getLineage(destRealmSpecies)
    destParentLineage =getLineage(destRealmSpecies,masks=c(destTaxonRank))

    # check where this name may or may not exist already
    srcCurMatches=(curMSL$name==as.character(srcTaxonName))
    destCurMatches=(curMSL$name==as.character(destTaxonName))
    destOldMatches=(oldMSLs$name==as.character(destTaxonName))
    destNewMatches=(newMSL$name==as.character(destTaxonName))

    # debug
    # print(paste("srcCurMatches=",sum(srcCurMatches),", destCurMatches=",sum(destCurMatches),",destOldMatches=",sum(destOldMatches),",destNewMatches=",sum(destNewMatches)))
    
    #
    # make sure new taxon does not exist already
    #
    if(!is.na(destTaxonName)) {
      # check if exists in the current MSL
      if(sum(destCurMatches)>0) {
        matchDf = curMSL[destCurMatches,c("msl_release_num","lineage")]
        matchDf = curMSL[order(matchDf$msl_release_num,decreasing = T)[1],]
        matchLineage = paste0( "MSL", matchDf$msl_release_num,":",matchDf$lineage)
        errorDf=addError(errorDf,code,linenum, "ERROR", "DEST.IN_CUR", 
                         paste0("Change=",toupper(action),", but 'proposed taxonomy' already exists"), 
                         paste0("XLSX ROW ",linenum,
                                ", proposedTaxonomy=", destTaxonName, 
                                "; existingTaxon=", matchLineage)
        )
        next;
      }
      # check if exists in a historical MLS (not the most recent)
      if(sum(destOldMatches)>0) {
        matchDf = oldMSLs[destOldMatches,c("msl_release_num","lineage")]
        matchDf = oldMSLs[order(matchDf$msl_release_num,decreasing = T)[1],]
        matchLineage = paste0( "MSL", matchDf$msl_release_num,":",matchDf$lineage)
        errorDf=addError(errorDf,code,linenum, "ERROR", "DEST.IN_OLD", 
                         paste0("Change=",toupper(action),",  but 'proposed taxonomy' existed historically"), 
                         paste0("XLSX ROW ",linenum,
                                ", proposedTaxonomy=", destTaxonName, 
                                "; existingTaxon=", matchLineage)
        )
        next;
      }
      # check if already created in newMSL
      if(sum(destNewMatches)>0) {
        matchDf = newMSL[destNewMatches,c("msl_release_num","lineage")]
        matchDf = newMSL[order(matchDf$msl_release_num,decreasing = T)[1],]
        matchLineage = paste0( "MSL", matchDf$msl_release_num,":",matchDf$lineage)
        errorDf=addError(errorDf,code,linenum, "ERROR", "DEST.IN_NEW", 
                         paste0("Change=",toupper(action),", but 'proposed taxonomy' already created in new MSL"), 
                         paste0("XLSX ROW ",linenum,
                                ", proposedTaxonomy=", destTaxonName, 
                                "; existingTaxon=", matchLineage,
                                "; otherProposal=", matchDf[1,"in_filename"]
                              )
        )
        next;
      }
      # WARN: check if taxon rank matches change rank
      if ( tolower(destTaxonRank) != tolower(change$rank) ) {
        errorDf=addError(errorDf,code,linenum, "WARNING", "DEST.RANK_MISMATCH", 
                         paste0("Change=",toupper(action)," but proposed taxon rank does not match [rank] column"), 
                         paste0("XLSX ROW ",linenum,", rankColumn=", change$rank,
                                ", proposedTaxonRank=",destTaxonRank,
                                ", proposedTaxonomy=", destLineage)
        )
      }
    } # if(!is.na(destTaxonName))
    
    #  -------------------------------------------------------------------------
    # CREATE 
    #
    # TODO: also handle SPLIT?
    #
    # Note: doesn't fix left_idx/right_idx, etc
    #  -------------------------------------------------------------------------
    if(actionClean %in% c("create") ) {

      # check if srcTaxon was specified in xlsx (shouldn't me)
      if(!is.na(srcTaxonName)) {
        errorDf=addError(errorDf,code,linenum, "ERROR", "CREATE.W_SRC", "Change=CREATE, but 'current taxonomy' columns are  not empty", 
                         paste0("XLSX ROW ",linenum,", currentTaxonomy=", srcLineage)
        )
        next;
      }
     
      #
      # check if same accession number already exists
      #
      isDupAccession = (newMSL$genbank_accession_csv == change$exemplarAccession)
      if(sum(isDupAccession, na.rm=TRUE)>0) {
        errorDf=addError(errorDf,code,linenum, "ERROR", "CREATE.DUP_ACC", "Change=CREATE, a species with this accession number already exists", 
                         paste0("XLSX ROW ",linenum,", accession=", change$exemplarAccession, ", existingSpecies=",newMSL[isDupAccession,]$lineage)
        )
        ## QQQ what proposal created this? (from this round? historically? Need a function: last_modified())
        next;
        
      }
      # 
      # verify that PARENT taxon exists already in newMSL
      #
      parentDestNewMatches=(newMSL$name==as.character(destParentName))
      if(params$verbose) {print(paste0("CREATE:  line ",linenum," '",destTaxonName, "' findParent(",destParentName,")=",sum(parentDestNewMatches)))}
    
      if(sum(parentDestNewMatches)==0) {
         errorDf=addError(errorDf,code,linenum, "ERROR", "CREATE.PARENT_NO_EXIST", "Change=CREATE, but parent rank taxon does not exist", 
                         paste0("XLSX ROW ",linenum,", parentTaxon=", destParentName, ", proposedTaxonomy=", destLineage)
         )
         next;
      } else if(sum(parentDestNewMatches)>1) {
         errorDf=addError(errorDf,code,linenum, "ERROR", "CREATE.PARENT_MANY", "Change=CREATE, multiple taxa exist with parent name", 
                         paste0("XLSX ROW ",linenum,", parentTaxon=", destParentName, ", proposedTaxonomy=", destLineage)
         )
         next;
      } else {
        # WARN: check if taxon rank matches change rank
        if ( tolower(destTaxonRank) != tolower(change$rank) ) {
          errorDf=addError(errorDf,code,linenum, "WARNING", "CREATE.RANK_MISMATCH", 
                           "Change=CREATE, but proposed taxon rank does not match [rank] column", 
                           paste0("XLSX ROW ",linenum,", rankColumn=", change$rank,
                                  ", proposedTaxonRank=",destTaxonRank,
                                  ", proposedTaxonomy=", destLineage)
          )
        }

        # 
        # create new taxon
        #
        
        
        # get parent
        newTaxon = newMSL[parentDestNewMatches,]
        
        # WARN if PARENT_LINEAGE is not expected
        if( newTaxon$lineage != destParentLineage ) {
          errorDf=addError(errorDf,code,linenum, "WARNING", "CREATE.PARENT_LINEAGE", 
                           "Change=CREATE, proposed parent taxon exists, but not with expected lineage", 
                           paste0("XLSX ROW ",linenum,", proposedParentLinage=", destParentLineage,
                                  ", observedParentLineage=",newTaxon$lineage,
                                  ", otherProposals=",newTaxon$prev_proposals)
          )
        }
        
        # add new info - primary columns
        newTaxon[1,"in_change"]   = "create"
        newTaxon[1,"in_filename"] = proposalZip
        newTaxon[1,"in_notes"]    = paste0("linenum=",linenum)
        newTaxon[1,"in_target"]   = destLineage

        newTaxon[1,"name"]       = destTaxonName
        newTaxon[1,"level_id"]   = rankCV$id[rankCV$name==destTaxonRank]
        newTaxon[1,"rank"]       = destTaxonRank
        newTaxon[1,"parent_id"]  = newTaxon[1,"taxnode_id"]
        newTaxon[1,"taxnode_id"] = max(newMSL$taxnode_id)+1
        newTaxon[1,"ictv_id"]    = newTaxon$taxnode_id
        
        # genomeComposition = molecule_id 
        newTaxon[1,xlsx2dbMap["molecule"]] = dbCvMapList[["molecule"]][change[1,"molecule"] ]
      
        # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
        newTaxon[1,xlsx2dbMap["hostSource"]] = change[1,"hostSource"] 

        ## for species only
        if( destTaxonRank == "species" ) {
          # "genbank_accession_csv"
          newTaxon[1,xlsx2dbMap["exemplarAccession"]] = change[1,"exemplarAccession"] 
          # exemplar_name
          # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
          newTaxon[1,xlsx2dbMap["exemplarName"]] = change[1,"exemplarName"] 
          # "abbrev_csv"
          newTaxon[1,xlsx2dbMap["Abbrev"]] = change[1,"Abbrev"] 
          # "isolate_csv"
          newTaxon[1,xlsx2dbMap["exemplarIsolate"]] = change[1,"exemplarIsolate"] 
          # genome_coverage
          # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
          newTaxon[1,xlsx2dbMap["genomeCoverage"]]= change[1,"genomeCoverage"] 
          # genome_coverage
          # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
          newTaxon[1,xlsx2dbMap["genomeCoverage"]]= change[1,"genomeCoverage"] 
          # molecule_id is above (not species-specific)
          # host_source
          # NOTE: column does not (yet) exist in [taxonomy_node], only in [load_next_msl##]
          newTaxon[1,xlsx2dbMap["hostSource"]]= change[1,"hostSource"] 
          # comments
          newTaxon[1,xlsx2dbMap["comments"]]= change[1,"comments"]
        }
        
        # info-only columns - wont be saved to DB
        newTaxon[1,"rank"]       = destTaxonRank
        newTaxon[1,"lineage"]    = destLineage
 
        # add new taxon to newMSL
        if(params$verbose) {print(paste0("rbindlist(newMSL,",newTaxon[1,"taxnode_id"],":",destLineage,")"))}
        newMSL <<- rbindlist(list(newMSL,newTaxon),fill=TRUE)
      } # create new taxon
    } else  if(actionClean %in% c("rename") ) {
    
      #  -------------------------------------------------------------------------
      #
      # RENAME 
      #
      #  -------------------------------------------------------------------------

      # check if srcTaxon was specified in xlsx (required)
      if(is.na(srcTaxonName)) {
        errorDf=addError(errorDf,code,linenum, "ERROR", "RENAME.WO_SRC", "Change=RENAME, but 'current taxonomy' columns are empty", 
                         paste0("XLSX ROW ",linenum,", currentTaxonomy=", srcLineage, ", destTaxonomy=", destLineage)
        )
        next;
      }
      
      #
      # find the target to rename in NEW
      #
      srcNewTarget=(newMSL$name==as.character(srcTaxonName))
      if(params$verbose) {print(paste0("RENAME: line ",linenum," '",destTaxonName, "' findTarget(",srcTaxonName,")=",sum(srcNewTarget)))}
    
      if(sum(srcNewTarget)==0) {
         errorDf=addError(errorDf,code,linenum, "ERROR", "RENAME.NO_EXIST", "Change=RENAME, but taxon does not exist", 
                         paste0("XLSX ROW ",linenum,", taxon=", srcTaxonName, ", lineage=",srcLineage,", proposedTaxon=", destTaxonName))
         next;
      } else if(sum(srcNewTarget)>1) {
         errorDf=addError(errorDf,code,linenum, "ERROR", "RENAME.MANY", "Change=RENAME, multiple taxa exist with parent name", 
                         paste0("XLSX ROW ",linenum,", taxon=", srcTaxonName, ", lineage=",srcLineage,", proposedTaxon=", destTaxonName
                                , " matches ", sum(srcNewTarget) ))
         next;
      } else {
        
        # find original taxon in prevMSL being renamed
        srcPrevTarget=(curMSL$taxnode_id==newMSL[srcNewTarget,]$prev_taxnode_id)
        srcNewParent= (newMSL$taxnode_id==newMSL[srcNewTarget,]$parent_id )
        # print(paste("srcPrevTarget=",sum(srcPrevTarget),"srcNewParent=",sum(srcNewParent)))
        
        # change the name and update lineage
        newMSL[srcNewTarget,"name"] = destTaxonName
        newMSL[srcNewTarget,"linage"] = paste(newMSL[srcNewParent,"lineage"],destTaxonName,sep=";") # should we do this? 
        # append proposal
        newMSL[srcNewTarget,"prev_proposals"] = paste0(
          ifelse(is.na(newMSL[srcNewTarget,"prev_proposals"]),"",paste0(newMSL[srcNewTarget,"prev_proposals"],",")),
          proposalZip,":",linenum)
        
        # put out_* changes on curMSL
        curMSL[srcPrevTarget,"out_updated"] = TRUE  # admin; mark this to save to db
        curMSL[srcPrevTarget,"out_change"] = "rename"
        curMSL[srcPrevTarget,"out_filename"] = proposalZip
        curMSL[srcPrevTarget,"out_target"] = destTaxonName
        curMSL[srcPrevTarget,"out_notes"] = paste0("linenum=",linenum)
        ## ZZZ add comments to out_notes?
      } # target found
      # RENAME
    } else if(actionClean %in% c("abolish") ) { 
      #  -------------------------------------------------------------------------
      #
      # ABOLISH 
      #
      #  -------------------------------------------------------------------------
      # check if srcTaxon was specified in xlsx (required)
      if(is.na(srcTaxonName)) {
        errorDf=addError(errorDf,code,linenum, "ERROR", "ABOLISH.WO_SRC", "Change=ABOLISH, but 'current taxonomy' columns are empty", 
                         paste0("XLSX ROW ",linenum,", currentTaxonomy=", srcLineage, ", destTaxonomy=", destLineage)
        )
        next;
      }
      
      #
      # find the target to abolish in NEW and CUR
      #
      srcNewTarget=(newMSL$name==as.character(srcTaxonName))
      srcPrevTarget=(curMSL$taxnode_id==newMSL[srcNewTarget,]$prev_taxnode_id)

      if(params$verbose) {print(paste0("ABOLISH: line ",linenum," '",srcTaxonName, "' findTarget(",srcTaxonName,")=",sum(srcNewTarget),"/",sum(srcPrevTarget)))}
    
      if(sum(srcNewTarget)==0) {
         errorDf=addError(errorDf,code,linenum, "ERROR", "ABOLISH.NO_EXIST", "Change=ABOLISH, but taxon does not exist", 
                         paste0("XLSX ROW ",linenum,", taxon=", srcTaxonName, ", lineage=",srcLineage,", proposedTaxon=", destTaxonName))
         next;
      } else if(sum(srcNewTarget)>1) {
         errorDf=addError(errorDf,code,linenum, "ERROR", "ABOLISH.MANY", "Change=ABOLISH, multiple taxa exist with name", 
                         paste0("XLSX ROW ",linenum,", taxon=", srcTaxonName, ", lineage=",srcLineage,", proposedTaxon=", destTaxonName
                                , " matches ", sum(srcNewTarget) ))
         next;
      }
      # remove taxon from NEW
      newMSL = newMSL[-srcNewTarget,]
      
      # put out_* changes on curMSL
      curMSL[srcPrevTarget,"out_updated"] = TRUE  # admin; mark this to save to db
      curMSL[srcPrevTarget,"out_change"] = "abolish"
      curMSL[srcPrevTarget,"out_filename"] = proposalZip
      curMSL[srcPrevTarget,"out_target"] = destTaxonName
      curMSL[srcPrevTarget,"out_notes"] = paste0("linenum=",linenum) # add comments?
       
    } else {
      #  -------------------------------------------------------------------------
      #
      # ACTION not implemented.
      #
      #  -------------------------------------------------------------------------
      errorDf=addError(errorDf,code,linenum, "ERROR", "CHANGE.UNIMP", 
                       paste0("Change=",toupper(action)," is NOT (yet) implemented"), 
                         paste0("XLSX ROW ",linenum,", taxon=", srcTaxonName, ", lineage=",srcLineage,", proposedTaxon=", destTaxonName)
                       )
      next;
  
    } # ACTION UN-IMP
 
  } # for each line in XLSX

  return(list(errorDf=errorDf))
} # apply_changes()
```

# process changes

```{r process_changes}

# ------------------------------------------------------------------------------
#
# GLOBAL VARS
# 
# ------------------------------------------------------------------------------
#
# extract current taxonomy
#
oldMSLs = subset(taxonomyDt, msl_release_num < params$prev_msl)
curMSL = subset(taxonomyDt, msl_release_num==params$prev_msl)
# add accounting columns
curMSL[,"out_updated"] = FALSE

#
# copy prev MSL to make new MSL,
# to which we will try and apply these edits
#
newMSL=createNewMSL(curMSL,params$prev_msl, params$next_msl, params$taxnode_delta)

#
# DEBUG ONLY - delete all load/QC errors in allErrorDf
allErrorDf = allErrorDf[FALSE,] # debug - reset errors

#
# iterate through proposals
#   iterate through changes
#
for( code in rownames(proposals)) {
  # code = rownames(proposals)[1]; code # debug 
  # code = rownames(proposals)[2]; code # debug 
  # code = rownames(proposals)[3]; code # debug 
  # code = rownames(proposals)[4]; code # debug 
  # code = rownames(proposals)[8]; code # debug - 20221013 current crash: around "Suid alphaherpesvirus 1"
  # code = rownames(proposals)[which(code==rownames(proposals))+1];; code # DEBUG NEXT
  # make sure we were able to load the changesDf
  #
  changeDf = changeList[[code]]
  if( is.null(changeDf) ) {
    if(params$verbose>1) {cat("SKIP ",code,": no changeDf loaded\n")}
  } else {
    #
    # iterate over changes
    #
    cat("# START PROC: ",code," with ", nrow(changeDf), " changes\n")
    result=apply_changes(code,proposals[code,"basename"],changeDf)
    errorDf = results[["errorDf"]]
    cat("# PROCed: ",code," with ",nrow(errorDf)," errors/warnings\n")
    if(nrow(errorDf)>0){allErrorDf=rbindlist(list(allErrorDf,errorDf),fill=TRUE)}
  } # if have proposal XLSX
} # proposal code

# write current error list
write_xlsx( x=allErrorDf,path=file.path(params$out_dir,"QC.summary.xlsx"))
write_delim(x=allErrorDf,file=file.path(params$out_dir,"QC.summary.tsv"), delim="\t")
```

# known problems

```{r final_stats}

dim(curMSL)
dim(newMSL)
dim(allErrorDf)

print("What is that ?space?: it's not a space, nor a tab:")
newMSL[grep(newMSL$lineage, pattern="Orthornavirae.;"),c("taxnode_id","parent_id","lineage","name","cleaned_name","in_filename","in_notes")]
#                                                                                                         lineage         name cleaned_name
# 1: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus L Pestivirus L   Pestivirus
# 2: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus M Pestivirus M   Pestivirus
# 3: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus N Pestivirus N   Pestivirus
# 4: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus O Pestivirus O   Pestivirus
# 5: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus P Pestivirus P   Pestivirus
# 6: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus Q Pestivirus Q   Pestivirus
# 7: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus R Pestivirus R   Pestivirus
# 8: Riboviria;Orthornavirae ;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus;Pestivirus S Pestivirus S   Pestivirus

newMSL[taxnode_id==202203151, c("taxnode_id","parent_id","lineage","name","cleaned_name","in_filename","in_notes")]
#   taxnode_id parent_id                                                                                        lineage       name cleaned_name
#1:  202203151 202203068 Riboviria;Orthornavirae;Kitrinoviricota;Flasuviricetes;Amarillovirales;Flaviviridae;Pestivirus Pestivirus   Pestivirus
  
# fix it
#(gsub(pattern="[^a-zA-Z]",replacement="",x$kingdom))

#
# but need to scan and report the problems before fixing them!!!!

```
